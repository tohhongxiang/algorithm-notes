# 3459. Length of Longest V-Shaped Diagonal Segment

- https://leetcode.com/problems/length-of-longest-v-shaped-diagonal-segment/description

# Solution

1. We go through every element in the grid. If the element is a 1, we can start the search for the longest V-shaped diagonal segment.
2. The search uses DFS. We check the following conditions:
   1. The current coordinate `(i, j)` is within the grid.
   2. The next element is valid:
      - When the current element is `1`, the next element has to be `2`.
      - When the current element is `2`, the next element has to be `0`.
      - When the current element is `0`, the next element has to be `2`.

      We use `current_element` to keep track of what the current element should be to have a valid path.
3. If we can continue to the next element in the same direction, we continue down that path. We use `direction` to keep track of the direction of this path.
4. If we are allowed to turn, we turn **only clockwise**, and then continue down the path. After this point, the path cannot turn again, hence we require a variable `can_turn` to track whether we are allowed to turn.
5. We compare which path is longer, and return that result.
6. To improve the time, we use `dp` to cache the result of our calculations. Then before the start of `dfs`, we check whether we have already calculated the result, and return it immediately if we have already calculated it previously. If not, we calculate the current result, update `dp`, and return the calculated result.

```py
class Solution:
    def lenOfVDiagonal(self, grid: List[List[int]]) -> int:
        dp = {}
        next_elements = { 1: 2, 2: 0, 0: 2 }
        next_directions = {
            (-1, -1): (-1, 1),
            (-1, 1): (1, 1),
            (1, 1): (1, -1),
            (1, -1): (-1, -1)
        }

        def dfs(i, j, direction, can_turn, current_element):
            # Already calculated
            if (i, j, direction, can_turn, current_element) in dp:
                return dp[(i, j, direction, can_turn, current_element)]

            # Currently on an invalid element
            if i < 0 or i > len(grid) - 1 or j < 0 or j > len(grid[0]) - 1 or grid[i][j] != current_element:
                return 0

            next_element = next_elements[current_element]
            result = 1 + dfs(i + direction[0], j + direction[1], direction, can_turn, next_element) # Continue in the same direction
            
            # Turn clockwise if able to
            if can_turn:
                next_direction = next_directions[direction]
                next_i, next_j = i + next_direction[0], j + next_direction[1]
                result = max(result, 1 + dfs(next_i, next_j, next_direction, False, next_element))

            # Update cache and return
            dp[(i, j, direction, can_turn, current_element)] = result
            return result

        result = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    for direction in [(-1, -1), (1, -1), (-1, 1), (1, 1)]:
                        result = max(result, dfs(i, j, direction, True, 1))

        return result
```

For an $N \times M$ grid:
- Time complexity: $O(MN)$
- Space complexity: $O(MN)$